"""
GitHub Issues Agent for managing issues, PRs, and security improvements
"""

import asyncio
import json
import logging
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List

from .agent_types import AgentCapability
from .base_agent import BaseAgent
from .task_system import Task, TaskResult


class GitHubActionType(Enum):
    """Types of GitHub actions the agent can perform"""

    REVIEW_PR = "review_pr"
    ANALYZE_ISSUE = "analyze_issue"
    RESPOND_TO_COMMENT = "respond_to_comment"
    LABEL_ISSUE = "label_issue"
    MERGE_PR = "merge_pr"
    CLOSE_ISSUE = "close_issue"
    CREATE_ISSUE = "create_issue"
    SECURITY_REVIEW = "security_review"
    GENERATE_REPORT = "generate_report"


class GitHubIssuesAgent(BaseAgent):
    """Agent responsible for managing GitHub issues and pull requests"""

    def __init__(self, agent_id: str = "github-issues-agent", repo: str = None):
        capabilities = [
            AgentCapability.BUSINESS_INTELLIGENCE  # Using BI for issue management
        ]
        super().__init__(agent_id=agent_id, capabilities=capabilities)
        self.logger = logging.getLogger(f"GitHubIssuesAgent-{agent_id}")
        self.repo = repo or "IgorGanapolsky/ai-kindlemint-engine"

        # Security improvement patterns
        self.security_bots = ["pixeebot", "dependabot", "snyk-bot"]
        self.auto_approve_patterns = [
            "Add timeout to requests calls",
            "Secure Source of Randomness",
            "Bump .* from .* to .*",  # Dependency updates
        ]

    async def _execute_task(self, task: Task) -> TaskResult:
        """Execute GitHub-related task"""
        try:
            action_type = task.input_data.get("action_type")

            if action_type == GitHubActionType.REVIEW_PR.value:
                return await self._review_pull_request(task)
            elif action_type == GitHubActionType.ANALYZE_ISSUE.value:
                return await self._analyze_issue(task)
            elif action_type == GitHubActionType.SECURITY_REVIEW.value:
                return await self._review_security_pr(task)
            elif action_type == GitHubActionType.GENERATE_REPORT.value:
                return await self._generate_issues_report(task)
            else:
                return TaskResult(
                    success=False,
                    task_id=task.task_id,
                    agent_id=self.agent_id,
                    error_message=f"Unsupported action type: {action_type}",
                )

        except Exception as e:
            self.logger.error(f"GitHub task failed: {e}")
            return TaskResult(
                success=False,
                task_id=task.task_id,
                agent_id=self.agent_id,
                error_message=str(e),
                error_details={"type": type(e).__name__},
            )

    async def _review_pull_request(self, task: Task) -> TaskResult:
        """Review a pull request"""
        pr_number = task.input_data.get("pr_number")
        if not pr_number:
            return TaskResult(
                success=False,
                task_id=task.task_id,
                agent_id=self.agent_id,
                error_message="Missing pr_number",
            )

        # Get PR details
        pr_data = await self._run_gh_command(
            [
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self.repo,
                "--json",
                "title,body,author,files,additions,deletions,labels",
            ]
        )

        if not pr_data:
            return TaskResult(
                success=False,
                task_id=task.task_id,
                agent_id=self.agent_id,
                error_message="Failed to fetch PR data",
            )

        # Generate review based on PR data
        files_count = len(pr_data.get("files", []))
        additions = pr_data["additions"]
        deletions = pr_data["deletions"]

        # Simple review logic based on PR characteristics
        if pr_data["author"]["login"].lower() in self.security_bots:
            review = f"""Security improvement from {pr_data['author']['login']}.

Changes: +{additions} -{deletions} across {files_count} files.

This appears to be an automated security improvement. Key considerations:
- Verify changes are limited to security improvements
- Check that no functional code is altered
- Ensure tests still pass after changes"""
        else:
            review = f"""Pull request from {pr_data['author']['login']}.

Changes: +{additions} -{deletions} across {files_count} files.

This PR requires manual review to assess:
1. Code quality and style compliance
2. Test coverage for new changes
3. Documentation updates if needed
4. Potential impact on existing functionality"""

        # Post review comment
        review_comment = f"""## ðŸ¤– AI Review

{review}

---
*Generated by KindleMint GitHub Issues Agent*
"""

        await self._run_gh_command(
            [
                "pr",
                "review",
                str(pr_number),
                "--repo",
                self.repo,
                "--comment",
                "--body",
                review_comment,
            ]
        )

        return TaskResult(
            success=True,
            task_id=task.task_id,
            agent_id=self.agent_id,
            output_data={
                "pr_number": pr_number,
                "review": review,
                "author": pr_data["author"]["login"],
            },
        )

    async def _review_security_pr(self, task: Task) -> TaskResult:
        """Review security-related PRs (like from Pixeebot)"""
        pr_number = task.input_data.get("pr_number")
        auto_approve = task.input_data.get("auto_approve", False)

        # Get PR details
        pr_data = await self._run_gh_command(
            [
                "pr",
                "view",
                str(pr_number),
                "--repo",
                self.repo,
                "--json",
                "title,body,author,files",
            ]
        )

        if not pr_data:
            return TaskResult(
                success=False,
                task_id=task.task_id,
                agent_id=self.agent_id,
                error_message="Failed to fetch PR data",
            )

        author = pr_data["author"]["login"]
        title = pr_data.get("title", "")

        # Check if it's from a known security bot
        is_security_bot = author.lower() in self.security_bots

        # Check if it matches auto-approve patterns
        should_auto_approve = (
            auto_approve
            and is_security_bot
            and any(pattern in title for pattern in self.auto_approve_patterns)
        )

        if should_auto_approve:
            # Auto-approve and merge
            self.logger.info(f"Auto-approving security PR #{pr_number} from {author}")

            # Approve PR
            await self._run_gh_command(
                [
                    "pr",
                    "review",
                    str(pr_number),
                    "--repo",
                    self.repo,
                    "--approve",
                    "--body",
                    "âœ… Auto-approved security improvement",
                ]
            )

            # Merge PR
            await self._run_gh_command(
                [
                    "pr",
                    "merge",
                    str(pr_number),
                    "--repo",
                    self.repo,
                    "--auto",
                    "--merge",
                ]
            )

            action_taken = "auto_approved_and_merged"
        else:
            # Manual review required
            review_comment = f"""## ðŸ”’ Security Review Required

**Author**: {author}
**Type**: {"Known security bot" if is_security_bot else "Unknown source"}

This PR requires manual review before merging.

### Checklist:
- [ ] Changes are limited to security improvements
- [ ] No functional code changes
- [ ] Dependencies are from trusted sources
- [ ] Tests still pass

---
*KindleMint Security Review Agent*
"""

            await self._run_gh_command(
                [
                    "pr",
                    "review",
                    str(pr_number),
                    "--repo",
                    self.repo,
                    "--comment",
                    "--body",
                    review_comment,
                ]
            )

            action_taken = "manual_review_requested"

        return TaskResult(
            success=True,
            task_id=task.task_id,
            agent_id=self.agent_id,
            output_data={
                "pr_number": pr_number,
                "author": author,
                "is_security_bot": is_security_bot,
                "action_taken": action_taken,
            },
        )

    async def _analyze_issue(self, task: Task) -> TaskResult:
        """Analyze and respond to an issue"""
        issue_number = task.input_data.get("issue_number")

        # Get issue details
        issue_data = await self._run_gh_command(
            [
                "issue",
                "view",
                str(issue_number),
                "--repo",
                self.repo,
                "--json",
                "title,body,author,labels,comments",
            ]
        )

        if not issue_data:
            return TaskResult(
                success=False,
                task_id=task.task_id,
                agent_id=self.agent_id,
                error_message="Failed to fetch issue data",
            )

        # Check if it's a Pixeebot activity dashboard
        if issue_data["author"][
            "login"
        ].lower() == "pixeebot" and "Activity Dashboard" in issue_data.get("title", ""):
            # Handle Pixeebot dashboard
            response = await self._handle_pixeebot_dashboard(issue_data)
        else:
            # Generate issue analysis based on data
            title = issue_data.get("title", "")
            body = issue_data.get("body", "")
            labels = [l["name"] for l in issue_data.get("labels", [])]

            # Simple categorization logic
            category = "question"  # default
            if any(word in title.lower() for word in ["bug", "error", "broken", "fix"]):
                category = "bug"
            elif any(
                word in title.lower() for word in ["feature", "add", "implement", "new"]
            ):
                category = "feature"
            elif any(
                word in title.lower() for word in ["docs", "documentation", "readme"]
            ):
                category = "documentation"

            # Priority based on keywords
            priority = "medium"  # default
            if any(
                word in body.lower()
                for word in ["urgent", "critical", "asap", "breaking"]
            ):
                priority = "high"
            elif any(
                word in body.lower()
                for word in ["minor", "low priority", "when possible"]
            ):
                priority = "low"

            response = f"""## Issue Analysis

**Category**: {category}
**Priority**: {priority}
**Current Labels**: {', '.join(labels) if labels else 'None'}

### Suggested Actions:
1. Add label: `{category}`
2. Set priority label: `priority:{priority}`
3. Assign to appropriate team member
4. Add to project board if applicable

### Recommended Response:
Thank you for reporting this issue. We'll review it and provide an update soon."""

        return TaskResult(
            success=True,
            task_id=task.task_id,
            agent_id=self.agent_id,
            output_data={
                "issue_number": issue_number,
                "analysis": response,
                "author": issue_data["author"]["login"],
            },
        )

    async def _handle_pixeebot_dashboard(self, issue_data: Dict) -> str:
        """Handle Pixeebot activity dashboard"""
        body = issue_data.get("body", "")

        # Extract recommendations
        recommendations = []
        if "Available" in body:
            # Parse available improvements
            lines = body.split("\n")
            in_available = False
            for line in lines:
                if "### Available" in line:
                    in_available = True
                elif "###" in line:
                    in_available = False
                elif in_available and line.strip().startswith("-"):
                    recommendations.append(line.strip())

        response = f"""## Pixeebot Security Improvements Analysis

**Status**: Active monitoring
**Recommendations found**: {len(recommendations)}

### Available Improvements:
{chr(10).join(recommendations) if recommendations else 'No new recommendations'}

### Recommended Actions:
1. Review each security improvement carefully
2. Auto-approve minor dependency updates
3. Manual review for code changes
4. Run tests before merging

### Next Steps:
- Use `@pixeebot next` to see additional improvements
- Check PR #25 for pending security fixes

*This dashboard is automatically updated weekly.*
"""

        return response

    async def _generate_issues_report(self, task: Task) -> TaskResult:
        """Generate a report of all issues and PRs"""
        # Get open issues
        issues = await self._run_gh_command(
            [
                "issue",
                "list",
                "--repo",
                self.repo,
                "--json",
                "number,title,author,labels,createdAt,state",
                "--limit",
                "50",
            ]
        )

        # Get open PRs
        prs = await self._run_gh_command(
            [
                "pr",
                "list",
                "--repo",
                self.repo,
                "--json",
                "number,title,author,labels,createdAt,state",
                "--limit",
                "50",
            ]
        )

        # Generate report
        report = {
            "generated_at": datetime.now().isoformat(),
            "repository": self.repo,
            "summary": {
                "open_issues": len([i for i in issues if i["state"] == "OPEN"]),
                "open_prs": len([p for p in prs if p["state"] == "OPEN"]),
                "security_items": 0,
            },
            "issues": issues,
            "pull_requests": prs,
            "security_bots_active": [],
        }

        # Check for security bots
        all_authors = set()
        for item in issues + prs:
            all_authors.add(item["author"]["login"].lower())

        report["security_bots_active"] = [
            bot for bot in self.security_bots if bot in all_authors
        ]

        report["summary"]["security_items"] = len(
            [
                item
                for item in issues + prs
                if item["author"]["login"].lower() in self.security_bots
            ]
        )

        return TaskResult(
            success=True,
            task_id=task.task_id,
            agent_id=self.agent_id,
            output_data=report,
            metrics={
                "total_items": len(issues) + len(prs),
                "security_items": report["summary"]["security_items"],
            },
        )

    async def _run_gh_command(self, args: List[str]) -> Any:
        """Run a GitHub CLI command and return JSON output"""
        try:
            cmd = ["gh"] + args

            result = await asyncio.create_subprocess_exec(
                *cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await result.communicate()

            if result.returncode != 0:
                self.logger.error(f"gh command failed: {stderr.decode()}")
                return None

            # Parse JSON output if applicable
            output = stdout.decode().strip()
            if output and args[-1] in [
                "--json",
                "number,title,author,labels,createdAt,state",
            ]:
                try:
                    return json.loads(output)
                except json.JSONDecodeError:
                    return output

            return output

        except Exception as e:
            self.logger.error(f"Failed to run gh command: {e}")
            return None

    async def validate_capabilities(self) -> Dict[str, Any]:
        """Validate agent capabilities"""
        # Check if gh CLI is available
        gh_available = await self._run_gh_command(["--version"]) is not None

        # Check authentication
        auth_status = await self._run_gh_command(["auth", "status"]) is not None

        return {
            "gh_cli_available": gh_available,
            "authenticated": auth_status,
            "supported_actions": [action.value for action in GitHubActionType],
            "security_bots_monitored": self.security_bots,
            "auto_approve_enabled": bool(self.auto_approve_patterns),
        }

    async def _initialize(self) -> None:
        """Initialize the agent"""
        self.logger.info(f"Initializing GitHub Issues Agent for repo: {self.repo}")
        # Verify gh CLI is available
        gh_check = await self._run_gh_command(["--version"])
        if not gh_check:
            self.logger.error("GitHub CLI (gh) not available")

    async def _cleanup(self) -> None:
        """Cleanup agent resources"""
        self.logger.info("Cleaning up GitHub Issues Agent")
        # No specific cleanup needed for this agent
