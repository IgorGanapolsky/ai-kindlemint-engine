"""
Agent Generator - Dynamically creates AI agents with specified capabilities
"""

import logging
from datetime import datetime
from pathlib import Path
from textwrap import dedent
from typing import Dict, List


class AgentGenerator:
    """
    Generates specialized AI agents on demand
    """

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.template_dir = Path(__file__).parent / "templates"

    async def generate(
        self,
        agent_type: str,
        capabilities: List[str],
        framework: str = "langchain",
        output_path: str = None,
        specialized: bool = False,
        **kwargs,
    ) -> Dict:
        """
        Generate a complete AI agent with specified capabilities
        """
        self.logger.info(
            f"Generating {agent_type} agent with capabilities: {capabilities}"
        )

        # Generate agent code
        agent_code = self._generate_agent_code(
            agent_type, capabilities, framework, specialized, **kwargs
        )

        # Generate tests
        test_code = self._generate_agent_tests(agent_type, capabilities)

        # Generate documentation
        docs = self._generate_agent_docs(agent_type, capabilities, **kwargs)

        # Write files
        output_path = output_path or f"./agents/{agent_type}_agent.py"
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write agent code
        with open(output_path, "w") as f:
            f.write(agent_code)

        # Write tests
        test_path = output_path.parent / f"test_{output_path.name}"
        with open(test_path, "w") as f:
            f.write(test_code)

        # Write documentation
        docs_path = output_path.parent / f"{output_path.stem}_docs.md"
        with open(docs_path, "w") as f:
            f.write(docs)

        return {
            "agent_path": str(output_path),
            "test_path": str(test_path),
            "docs_path": str(docs_path),
            "capabilities": capabilities,
            "framework": framework,
            "generated_at": datetime.now().isoformat(),
        }

    def _generate_agent_code(
        self,
        agent_type: str,
        capabilities: List[str],
        framework: str,
        specialized: bool,
        **kwargs,
    ) -> str:
        """Generate the agent Python code"""

        # Base imports
        imports = [
            "import asyncio",
            "import logging",
            "from typing import Dict, List, Optional, Any",
            "from datetime import datetime",
            "from pathlib import Path",
        ]

        # Framework-specific imports
        if framework == "langchain":
            imports.extend(
                [
                    "from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent",
                    "from langchain.llms import OpenAI",
                    "from langchain.memory import ConversationBufferMemory",
                ]
            )

        # Capability-specific imports
        if "content-generation" in capabilities:
            imports.append("from ..engines.content_generator import ContentGenerator")
        if "market-analysis" in capabilities:
            imports.append("from ..analytics.market_analyzer import MarketAnalyzer")
        if "seo-optimization" in capabilities:
            imports.append("from ..optimization.seo_optimizer import SEOOptimizer")

        # Generate class definition
        class_name = f"{agent_type.title().replace('-', '')}Agent"

        code = dedent(
            f"""
        \"\"\"
        {class_name} - AI agent specialized in {agent_type.replace('-', ' ')}
        Generated by Claude Code Orchestrator
        \"\"\"

        {chr(10).join(imports)}


        class {class_name}:
            \"\"\"
            Specialized agent for {agent_type.replace('-', ' ')} tasks

            Capabilities:
            {chr(10).join(f'    - {cap}' for cap in capabilities)}
            \"\"\"

            def __init__(self, config: Optional[Dict] = None):
                self.config = config or {{}}
                self.logger = logging.getLogger(__name__)
                self.capabilities = {capabilities}
                self._initialize_tools()

            def _initialize_tools(self):
                \"\"\"Initialize agent tools based on capabilities\"\"\"
                self.tools = []

        """
        ).strip()

        # Add capability-specific methods
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            code += dedent(
                f"""

            async def {method_name}(self, **kwargs) -> Dict:
                \"\"\"
                Perform {capability.replace('-', ' ')} tasks
                \"\"\"
                self.logger.info(f"Executing {capability} with params: {{kwargs}}")

                try:
                    # Implementation for {capability}
                    result = {{
                        "status": "success",
                        "capability": "{capability}",
                        "timestamp": datetime.now().isoformat()
                    }}

                    return result

                except Exception as e:
                    self.logger.error(f"Error in {capability}: {{e}}")
                    return {{
                        "status": "error",
                        "capability": "{capability}",
                        "error": str(e)
                    }}
            """
            )

        # Add specialized methods if needed
        if specialized:
            industry = kwargs.get("industry", "generic")
            compliance = kwargs.get("compliance", "")

            code += dedent(
                f"""

            async def industry_specific_process(self, data: Dict) -> Dict:
                \"\"\"
                Process data according to {industry} industry standards
                {f'Compliance: {compliance}' if compliance else ''}
                \"\"\"
                # Industry-specific implementation
                return {{
                    "industry": "{industry}",
                    "compliance": "{compliance}",
                    "processed": True
                }}
            """
            )

        # Add main execution method
        code += dedent(
            """

        async def execute(self, task: str, params: Dict = None) -> Dict:
            \"\"\"
            Execute a task using available capabilities
            \"\"\"
            params = params or {}

            self.logger.info(f"Executing task: {task}")

            # Route to appropriate capability
            if task in self.capabilities:
                method_name = task.replace('-', '_')
                if hasattr(self, method_name):
                    method = getattr(self, method_name)
                    return await method(**params)

            return {
                "status": "error",
                "message": f"Unknown task: {task}"
            }
        """
        )

        return code

    def _generate_agent_tests(self, agent_type: str, capabilities: List[str]) -> str:
        """Generate test code for the agent"""

        class_name = f"{agent_type.title().replace('-', '')}Agent"

        test_code = dedent(
            f"""
        \"\"\"
        Tests for {class_name}
        Generated by Claude Code Orchestrator
        \"\"\"

        import pytest
        import asyncio
        from pathlib import Path
        import sys

        # Add parent directory to path
        sys.path.insert(0, str(Path(__file__).parent))

        from {agent_type}_agent import {class_name}


        class Test{class_name}:
            \"\"\"Test suite for {class_name}\"\"\"

            @pytest.fixture
            def agent(self):
                \"\"\"Create agent instance for testing\"\"\"
                return {class_name}()

            def test_initialization(self, agent):
                \"\"\"Test agent initialization\"\"\"
                assert agent is not None
                assert agent.capabilities == {capabilities}

            @pytest.mark.asyncio
            async def test_execute_valid_task(self, agent):
                \"\"\"Test executing a valid task\"\"\"
                result = await agent.execute("{capabilities[0]}", {{}})
                assert result["status"] == "success"
                assert result["capability"] == "{capabilities[0]}"

            @pytest.mark.asyncio
            async def test_execute_invalid_task(self, agent):
                \"\"\"Test executing an invalid task\"\"\"
                result = await agent.execute("invalid-task", {{}})
                assert result["status"] == "error"
                assert "Unknown task" in result["message"]
        """
        ).strip()

        # Add tests for each capability
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            test_code += dedent(
                f"""

            @pytest.mark.asyncio
            async def test_{method_name}(self, agent):
                \"\"\"Test {capability.replace('-', ' ')} capability\"\"\"
                result = await agent.{method_name}()
                assert result["status"] == "success"
                assert result["capability"] == "{capability}"
            """
            )

        return test_code

    def _generate_agent_docs(
        self, agent_type: str, capabilities: List[str], **kwargs
    ) -> str:
        """Generate documentation for the agent"""

        class_name = f"{agent_type.title().replace('-', '')}Agent"

        docs = dedent(
            f"""
        # {class_name} Documentation

        Generated by Claude Code Orchestrator on {datetime.now().strftime('%Y-%m-%d')}

        ## Overview

        The {class_name} is a specialized AI agent designed for {agent_type.replace('-', ' ')} tasks.

        ## Capabilities

        This agent has the following capabilities:

        {chr(10).join(f'- **{cap}**: Handles {cap.replace("-", " ")} operations' for cap in capabilities)}

        ## Usage

        ```python
        from agents.{agent_type}_agent import {class_name}

        # Initialize the agent
        agent = {class_name}()

        # Execute a task
        result = await agent.execute("content-generation", {{
            "topic": "AI in Healthcare",
            "length": 1000
        }})
        ```

        ## Methods

        ### Core Methods

        - `__init__(config: Optional[Dict] = None)`: Initialize the agent
        - `execute(task: str, params: Dict = None) -> Dict`: Execute a task

        ### Capability Methods

        """
        ).strip()

        # Document each capability
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            docs += dedent(
                f"""

        #### `{method_name}(**kwargs) -> Dict`

        Performs {capability.replace('-', ' ')} operations.

        **Parameters:**
        - `**kwargs`: Task-specific parameters

        **Returns:**
        - `Dict`: Result dictionary with status and data
            """
            )

        # Add specialized documentation if needed
        if kwargs.get("specialized"):
            industry = kwargs.get("industry", "generic")
            compliance = kwargs.get("compliance", "")

            docs += dedent(
                f"""

        ## Industry Specialization

        This agent is specialized for the **{industry}** industry.

        {f'### Compliance: {compliance}' if compliance else ''}

        The agent follows industry-specific standards and best practices.
            """
            )

        return docs
