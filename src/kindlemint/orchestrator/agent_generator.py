"""
Agent Generator - Dynamically creates AI agents with specified capabilities
"""

import logging
from datetime import datetime
from pathlib import Path
from textwrap import dedent
from typing import Any, Dict, List, Optional


class AgentGenerator:
    """
    Generates specialized AI agents on demand
    """

    def __init__(self):
        """
        Initialize the AgentGenerator with a logger and set the template directory path.
        """
        self.logger = logging.getLogger(__name__)
        self.template_dir = Path(__file__).parent / "templates"

    async def generate(
        self,
        agent_type: str,
        capabilities: List[str],
        framework: str = "langchain",
        output_path: str = None,
        specialized: bool = False,
        **kwargs,
    ) -> Dict:
        """
        Generate a complete AI agent with specified capabilities
        """
        self.logger.info(
            f"Generating {agent_type} agent with capabilities: {capabilities}"
        )

        # Generate agent code
        agent_code = self._generate_agent_code(
            agent_type, capabilities, framework, specialized, **kwargs
        )

        # Generate tests
        test_code = self._generate_agent_tests(agent_type, capabilities)

        # Generate documentation
        docs = self._generate_agent_docs(agent_type, capabilities, **kwargs)

        # Write files
        output_path = output_path or f"./agents/{agent_type}_agent.py"
        output_path = Path(output_path)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # Write agent code
        with open(output_path, "w") as f:
            f.write(agent_code)

        # Write tests
        test_path = output_path.parent / f"test_{output_path.name}"
        with open(test_path, "w") as f:
            f.write(test_code)

        # Write documentation
        docs_path = output_path.parent / f"{output_path.stem}_docs.md"
        with open(docs_path, "w") as f:
            f.write(docs)

        return {
            "agent_path": str(output_path),
            "test_path": str(test_path),
            "docs_path": str(docs_path),
            "capabilities": capabilities,
            "framework": framework,
            "generated_at": datetime.now().isoformat(),
        }

    def _generate_agent_code(
        self,
        agent_type: str,
        capabilities: List[str],
        framework: str,
        specialized: bool,
        **kwargs,
    ) -> str:
        """
        Generate Python source code for an AI agent class with specified capabilities, framework, and optional specialization.

        Parameters:
            agent_type (str): The type of agent to generate (e.g., "content-generator").
            capabilities (List[str]): List of capability identifiers to include as async methods.
            framework (str): The framework to use for agent construction (e.g., "langchain").
            specialized (bool): Whether to include industry-specific processing methods.
            **kwargs: Additional options such as industry or compliance details for specialization.

        Returns:
            str: The generated Python source code as a string, defining the agent class with methods for each capability and optional specialization.
        """

        # Base imports
        imports = [
            "import asyncio",
            "import logging",
            "from typing import Dict, List, Optional, Any",
            "from datetime import datetime",
            "from pathlib import Path",
        ]

        # Framework-specific imports
        if framework == "langchain":
            imports.extend(
                [
                    "from langchain.agents import Tool, AgentExecutor, LLMSingleActionAgent",
                    "from langchain.llms import OpenAI",
                    "from langchain.memory import ConversationBufferMemory",
                ]
            )

        # Capability-specific imports
        if "content-generation" in capabilities:
            imports.append(
                "from ..engines.content_generator import ContentGenerator")
        if "market-analysis" in capabilities:
            imports.append(
                "from ..analytics.market_analyzer import MarketAnalyzer")
        if "seo-optimization" in capabilities:
            imports.append(
                "from ..optimization.seo_optimizer import SEOOptimizer")

        # Generate class definition
        class_name = f"{agent_type.title().replace('-', '')}Agent"

        code = dedent(
            f'''
        """
        {class_name} - AI agent specialized in {agent_type.replace('-', ' ')}
        Generated by Claude Code Orchestrator
        """

        {chr(10).join(imports)}


        class {class_name}:
            """
            Specialized agent for {agent_type.replace('-', ' ')} tasks

            Capabilities:
            {chr(10).join(f'    - {cap}' for cap in capabilities)}
            """

            def __init__(self, config: Optional[Dict] = None):
                self.config = config or {{}}
                self.logger = logging.getLogger(__name__)
                self.capabilities = {capabilities}
                self._initialize_tools()

            def _initialize_tools(self):
                """Initialize agent tools based on capabilities"""
                self.tools = []
        '''
        )

        # Add capability-specific methods
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            code += dedent(
                f"""

            async def {method_name}(self, **kwargs) -> Dict:
                \""\
                Perform {capability.replace('-', ' ')} tasks
                \""\
                self.logger.info(f"Executing {capability} with params: {{kwargs}}")

                try:
                    # Implementation for {capability}
                    result = {{
                        "status": "success",
                        "capability": "{capability}",
                        "timestamp": datetime.now().isoformat()
                    }}

                    return result

                except Exception as e:
                    self.logger.error(f"Error in {capability}: {{e}}")
                    return {{
                        "status": "error",
                        "capability": "{capability}",
                        "error": str(e)
                    }}
            """
            )

        # Add specialized methods if needed
        if specialized:
            industry = kwargs.get("industry", "generic")
            compliance = kwargs.get("compliance", "")
            compliance_str = f"Compliance: {compliance}" if compliance else ""
            code += dedent(
                f"""

            async def industry_specific_process(self, data: Dict) -> Dict:
                \""\
                Process data according to {industry} industry standards
                {compliance_str}
                \""\
                # Industry-specific implementation
                return {{
                    "industry": "{industry}",
                    "compliance": "{compliance}",
                    "processed": True
                }}
            """
            )

        # Add main execution method
        code += dedent(
            """

        async def execute(self, task: str, params: Dict = None) -> Dict:
            \""\
            Execute a task using available capabilities
            \""\
            params = params or {}

            self.logger.info(f"Executing task: {task}")

            # Route to appropriate capability
            if task in self.capabilities:
                method_name = task.replace('-', '_')
                if hasattr(self, method_name):
                    method = getattr(self, method_name)
                    return await method(**params)

            return {
                "status": "error",
                "message": f"Unknown task: {task}"
            }
        """
        )

        return code

    def _generate_agent_tests(self, agent_type: str, capabilities: List[str]) -> str:
        """
        Generate pytest-based test code for the dynamically created agent class.

        Parameters:
            agent_type (str): The type of agent to generate tests for.
            capabilities (List[str]): List of capability names the agent supports.

        Returns:
            str: The generated Python test code as a string.
        """

        class_name = f"{agent_type.title().replace('-', '')}Agent"

        test_code = dedent(
            f"""
        \""\
        Tests for {class_name}
        Generated by Claude Code Orchestrator
        \""\

        import pytest
        import asyncio
        from pathlib import Path
        import sys

        # Add parent directory to path
        sys.path.insert(0, str(Path(__file__).parent))

        from {agent_type}_agent import {class_name}


        class Test{class_name}:
            \""\"Test suite for {class_name}\""\"

            @pytest.fixture
            def agent(self):
                \""\"Create agent instance for testing\""\"
                return {class_name}()

            def test_initialization(self, agent):
                \""\"Test agent initialization\""\"
                assert agent is not None
                assert agent.capabilities == {capabilities}

            @pytest.mark.asyncio
            async def test_execute_valid_task(self, agent):
                \""\"Test executing a valid task\""\"
                result = await agent.execute("{capabilities[0]}", {{}})
                assert result["status"] == "success"
                assert result["capability"] == "{capabilities[0]}"

            @pytest.mark.asyncio
            async def test_execute_invalid_task(self, agent):
                \""\"Test executing an invalid task\""\"
                result = await agent.execute("invalid-task", {{}})
                assert result["status"] == "error"
                assert "Unknown task" in result["message"]
        """
        ).strip()

        # Add tests for each capability
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            test_code += dedent(
                f"""

            @pytest.mark.asyncio
            async def test_{method_name}(self, agent):
                \""\"Test {capability.replace('-', ' ')} capability\""\"
                result = await agent.{method_name}()
                assert result["status"] == "success"
                assert result["capability"] == "{capability}"
            """
            )

        return test_code

    def _generate_agent_docs(
        self, agent_type: str, capabilities: List[str], **kwargs
    ) -> str:
        """
        Generate Markdown documentation for a dynamically created agent class, including its overview, capabilities, usage example, method descriptions, and optional industry specialization details.

        Parameters:
                agent_type (str): The type of agent to document, used for class naming and description.
                capabilities (List[str]): List of capability names to document as agent methods.
                **kwargs: Optional parameters for specialization, such as 'specialized', 'industry', and 'compliance'.

        Returns:
                str: The complete Markdown documentation for the generated agent.
        """

        class_name = f"{agent_type.title().replace('-', '')}Agent"
        cap_list = "\n".join(
            f'- **{cap}**: Handles {cap.replace("-", " ")} operations'
            for cap in capabilities
        )

        docs = dedent(
            f"""
        # {class_name} Documentation

        Generated by Claude Code Orchestrator on {datetime.now().strftime('%Y-%m-%d')}

        ## Overview

        The {class_name} is a specialized AI agent designed for {agent_type.replace('-', ' ')} tasks.

        ## Capabilities

        This agent has the following capabilities:

        {cap_list}

        ## Usage

        ```python
        from agents.{agent_type}_agent import {class_name}

        # Initialize the agent
        agent = {class_name}()

        # Execute a task
        result = await agent.execute("content-generation", {{
            "topic": "AI in Healthcare",
            "length": 1000
        }})
        ```

        ## Methods

        ### Core Methods

        - `__init__(config: Optional[Dict] = None)`: Initialize the agent
        - `execute(task: str, params: Dict = None) -> Dict`: Execute a task

        ### Capability Methods

        """
        ).strip()

        # Document each capability
        for capability in capabilities:
            method_name = capability.replace("-", "_")
            docs += dedent(
                f"""

        #### `{method_name}(**kwargs) -> Dict`

        Performs {capability.replace('-', ' ')} operations.

        **Parameters:**
        - `**kwargs`: Task-specific parameters

        **Returns:**
        - `Dict`: Result dictionary with status and data
            """
            )

        # Add specialized documentation if needed
        if kwargs.get("specialized"):
            industry = kwargs.get("industry", "generic")
            compliance = kwargs.get("compliance", "")
            compliance_str = f"### Compliance: {compliance}" if compliance else ""
            docs += dedent(
                f"""

        ## Industry Specialization

        This agent is specialized for the **{industry}** industry.

        {compliance_str}

        The agent follows industry-specific standards and best practices.
            """
            )

        return docs
