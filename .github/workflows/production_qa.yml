name: Production QA Validation

on:
  push:
    paths:
      - 'books/active_production/**/*.pdf'
      - 'books/active_production/**/*.json'
  pull_request:
    paths:
      - 'books/active_production/**/*.pdf'
      - 'books/active_production/**/*.json'

jobs:
  qa-validation:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install PyPDF2 pillow reportlab
    - name: Find book directories
      id: find-books
      run: |
        echo "book_dirs=$(find books/active_production -type f -name collection.json -print0 | xargs -0 -n1 dirname | tr '\n' ' ')" >> $GITHUB_OUTPUT
    
    - name: Run Enhanced QA on each Book
      if: steps.find-books.outputs.book_dirs != ''
      run: |
        for dir in ${{ steps.find-books.outputs.book_dirs }}; do
          echo "Running Enhanced QA on $dir..."
          python scripts/enhanced_qa_validator_v2.py "$dir" --output-dir "$dir" || exit 1
        done
    
    - name: Check for test content in metadata
      run: |
        # Find all JSON files and check for "test" or "Test"
        for json_file in $(find books/active_production -name '*.json' -type f); do
          if grep -i "test" "$json_file"; then
            echo "‚ùå ERROR: Found 'test' in $json_file"
            exit 1
          fi
        done
        echo "‚úÖ No test content found in metadata files"
    
    - name: Upload QA Reports
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: qa-reports
        path: books/active_production/**/ENHANCED_QA_REPORT_*.json
        
    - name: Comment PR with QA Results
      if: github.event_name == 'pull_request' && always()
      uses: actions/github-script@v6
      with:
        script: |
          const fs = require('fs');
          let comment = '## üìä Production QA Results\n\n';
          
          // Find all QA reports
          const reports = require('child_process')
            .execSync('find books/active_production -name qa_production_report.json')
            .toString()
            .trim()
            .split('\n')
            .filter(Boolean);
          
          if (reports.length === 0) {
            comment += '‚ö†Ô∏è No QA reports generated\n';
          } else {
            for (const reportPath of reports) {
              try {
                const report = JSON.parse(fs.readFileSync(reportPath, 'utf8'));
                const book = reportPath.split('/').slice(-3, -1).join('/');
                
                comment += `### üìö ${book}\n`;
                comment += `- **Score**: ${report.score}/100\n`;
                comment += `- **Status**: ${report.ready ? '‚úÖ Ready' : '‚ùå Not Ready'}\n`;
                
                if (report.critical_issues.length > 0) {
                  comment += `- **Critical Issues**: ${report.critical_issues.length}\n`;
                  report.critical_issues.forEach(issue => {
                    comment += `  - ‚ùå ${issue}\n`;
                  });
                }
                
                if (report.warnings.length > 0) {
                  comment += `- **Warnings**: ${report.warnings.length}\n`;
                }
                
                comment += '\n';
              } catch (e) {
                comment += `### ‚ùå Error reading ${reportPath}\n\n`;
              }
            }
          }
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
    - name: üí¨ Send Slack Notification
      if: always()
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        if [ -z "$SLACK_WEBHOOK_URL" ]; then
          echo "No Slack webhook configured"
          exit 0
        fi
        
        # Check for test content failures
        TEST_CONTENT_FOUND=false
        if grep -i "test" books/active_production/**/*.json 2>/dev/null; then
          TEST_CONTENT_FOUND=true
        fi
        
        # Parse QA results
        TOTAL_BOOKS=0
        PASSED_BOOKS=0
        FAILED_BOOKS=0
        CRITICAL_ISSUES=""
        
        for report in $(find books/active_production -name "qa_production_report.json" 2>/dev/null); do
          TOTAL_BOOKS=$((TOTAL_BOOKS + 1))
          READY=$(jq -r '.ready' "$report" 2>/dev/null || echo "false")
          
          if [ "$READY" == "true" ]; then
            PASSED_BOOKS=$((PASSED_BOOKS + 1))
          else
            FAILED_BOOKS=$((FAILED_BOOKS + 1))
            BOOK_NAME=$(basename $(dirname "$report"))
            SCORE=$(jq -r '.score // 0' "$report" 2>/dev/null)
            CRITICAL_ISSUES="${CRITICAL_ISSUES}‚Ä¢ $BOOK_NAME: Score $SCORE/100\n"
          fi
        done
        
        # Determine overall status
        if [ "$TEST_CONTENT_FOUND" == "true" ]; then
          COLOR="danger"
          EMOJI="üö®"
          STATUS="Test content detected in metadata!"
        elif [ "$FAILED_BOOKS" -eq 0 ] && [ "$TOTAL_BOOKS" -gt 0 ]; then
          COLOR="good"
          EMOJI="‚úÖ"
          STATUS="All books ready for production"
        else
          COLOR="danger"
          EMOJI="‚ùå"
          STATUS="$FAILED_BOOKS books not ready for production"
        fi
        
        # Build message
        PAYLOAD=$(cat <<EOF
        {
          "attachments": [{
            "color": "$COLOR",
            "blocks": [
              {
                "type": "header",
                "text": {
                  "type": "plain_text",
                  "text": "$EMOJI Production QA Validation"
                }
              },
              {
                "type": "section",
                "fields": [
                  {
                    "type": "mrkdwn",
                    "text": "*Environment:* Production"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Books Validated:* $TOTAL_BOOKS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Ready:* $PASSED_BOOKS"
                  },
                  {
                    "type": "mrkdwn",
                    "text": "*Not Ready:* $FAILED_BOOKS"
                  }
                ]
              },
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": "*Status:* $STATUS"
                }
              }
        EOF
        )
        
        # Add issues if any
        if [ -n "$CRITICAL_ISSUES" ] && [ "$CRITICAL_ISSUES" != "" ]; then
          PAYLOAD="${PAYLOAD},
              {
                \"type\": \"section\",
                \"text\": {
                  \"type\": \"mrkdwn\",
                  \"text\": \"*Books Not Ready:*\n$CRITICAL_ISSUES\"
                }
              }"
        fi
        
        PAYLOAD="${PAYLOAD},
              {
                \"type\": \"context\",
                \"elements\": [{
                  \"type\": \"mrkdwn\",
                  \"text\": \"<https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Full Report> ‚Ä¢ ${{ github.event_name }}\"
                }]
              }
            ]
          }]
        }"
        
        echo "$PAYLOAD" | curl -X POST -H 'Content-type: application/json' \
          --data @- \
          "$SLACK_WEBHOOK_URL"