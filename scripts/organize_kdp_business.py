#!/usr/bin/env python3
"""
Strategic KDP Business Organization System
Implements 2025 best practices for scalable publishing business
"""

import os
import shutil
from pathlib import Path
from datetime import datetime
import json

def create_strategic_structure():
    """Create the strategic 2025 KDP business structure"""
    
    print("üèóÔ∏è CREATING STRATEGIC KDP BUSINESS STRUCTURE")
    print("=" * 60)
    
    # Root structure for 2025 KDP business
    structure = {
        "active_production": {
            "description": "Current series in development",
            "subdirs": []
        },
        "staging": {
            "description": "Ready for Amazon KDP publishing",
            "subdirs": []
        },
        "published_archive": {
            "description": "Git LFS archived completed books",
            "subdirs": ["2025_Q1", "2025_Q2", "2025_Q3", "2025_Q4"]
        },
        "templates": {
            "description": "Reusable assets and templates",
            "subdirs": ["covers", "metadata", "marketing", "kdp_guides"]
        },
        "business_intelligence": {
            "description": "Analytics, sales data, profit tracking",
            "subdirs": ["sales_reports", "profit_analysis", "market_research"]
        }
    }
    
    base_path = Path(".")
    
    for main_dir, config in structure.items():
        main_path = base_path / main_dir
        main_path.mkdir(exist_ok=True)
        
        # Create README for each main directory
        readme_content = f"""# {main_dir.replace('_', ' ').title()}

{config['description']}

## Purpose
This directory contains {config['description'].lower()}.

## Structure
"""
        
        for subdir in config['subdirs']:
            subdir_path = main_path / subdir
            subdir_path.mkdir(exist_ok=True)
            readme_content += f"- `{subdir}/` - {subdir.replace('_', ' ').title()}\n"
        
        readme_content += f"""
## Last Updated
{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

Generated by KindleMint Strategic Organization System
"""
        
        with open(main_path / "README.md", "w") as f:
            f.write(readme_content)
        
        print(f"‚úÖ Created: {main_dir}/ with {len(config['subdirs'])} subdirectories")
    
    return structure

def identify_best_content():
    """Identify the best version of each series for active production"""
    
    print("\nüéØ IDENTIFYING BEST CONTENT VERSIONS")
    print("=" * 60)
    
    output_path = Path("output")
    
    # Find all crossword series
    crossword_dirs = []
    for path in output_path.rglob("*Large_Print_Crossword_Masters*"):
        if path.is_dir():
            crossword_dirs.append(path)
    
    print(f"Found {len(crossword_dirs)} crossword directories:")
    
    best_versions = {}
    
    for dir_path in crossword_dirs:
        print(f"\nüìÅ Analyzing: {dir_path}")
        
        # Check for volume 1 manuscript
        vol1_manuscript = None
        for manuscript_path in dir_path.rglob("manuscript.txt"):
            if "volume_1" in str(manuscript_path):
                vol1_manuscript = manuscript_path
                break
        
        if vol1_manuscript and vol1_manuscript.exists():
            size = vol1_manuscript.stat().st_size
            print(f"   üìÑ Volume 1 manuscript: {size:,} bytes")
            
            # Determine quality level
            if size > 300000:  # 300KB+ = AI-generated comprehensive
                quality = "AI_COMPREHENSIVE"
                score = 100
            elif size > 100000:  # 100KB+ = enhanced template
                quality = "ENHANCED_TEMPLATE"  
                score = 80
            elif size > 50000:   # 50KB+ = basic template
                quality = "BASIC_TEMPLATE"
                score = 60
            else:                # <50KB = placeholder
                quality = "PLACEHOLDER"
                score = 20
            
            print(f"   üéØ Quality: {quality} (Score: {score})")
            
            series_key = "Large_Print_Crossword_Masters"
            if series_key not in best_versions or score > best_versions[series_key]["score"]:
                best_versions[series_key] = {
                    "path": dir_path,
                    "manuscript_path": vol1_manuscript,
                    "size": size,
                    "quality": quality,
                    "score": score
                }
        else:
            print(f"   ‚ùå No volume 1 manuscript found")
    
    print(f"\nüèÜ BEST VERSIONS IDENTIFIED:")
    for series, data in best_versions.items():
        print(f"   {series}: {data['quality']} ({data['size']:,} bytes)")
        print(f"      Path: {data['path']}")
    
    return best_versions

def migrate_to_active_production(best_versions):
    """Migrate best content to active_production structure"""
    
    print("\nüöÄ MIGRATING TO ACTIVE PRODUCTION")
    print("=" * 60)
    
    active_prod = Path("active_production")
    
    for series_name, data in best_versions.items():
        source_path = data["path"]
        target_path = active_prod / series_name
        
        print(f"üì¶ Migrating {series_name}...")
        print(f"   From: {source_path}")
        print(f"   To: {target_path}")
        
        # Create target directory
        target_path.mkdir(parents=True, exist_ok=True)
        
        # Copy the best version
        if source_path.exists():
            try:
                # Copy all contents
                shutil.copytree(source_path, target_path, dirs_exist_ok=True)
                print(f"   ‚úÖ Copied successfully")
                
                # Create series metadata
                metadata = {
                    "series_name": series_name,
                    "migration_date": datetime.now().isoformat(),
                    "source_path": str(source_path),
                    "quality_level": data["quality"],
                    "manuscript_size": data["size"],
                    "status": "active_development",
                    "next_volume": 2,
                    "target_volumes": 5
                }
                
                with open(target_path / "series_metadata.json", "w") as f:
                    json.dump(metadata, f, indent=2)
                
                print(f"   üìä Created series metadata")
                
            except Exception as e:
                print(f"   ‚ùå Copy failed: {e}")

def cleanup_old_directories():
    """Remove duplicate and outdated directories"""
    
    print("\nüßπ CLEANING UP OLD DIRECTORIES")
    print("=" * 60)
    
    # Directories to remove (keep only active_production versions)
    cleanup_paths = [
        "output/daily_production",  # All date-based production
        "output/ai_production",     # Temporary AI test output
    ]
    
    for cleanup_path in cleanup_paths:
        path = Path(cleanup_path)
        if path.exists():
            print(f"üóëÔ∏è Removing: {cleanup_path}")
            try:
                shutil.rmtree(path)
                print(f"   ‚úÖ Removed successfully")
            except Exception as e:
                print(f"   ‚ùå Failed to remove: {e}")
        else:
            print(f"‚è≠Ô∏è Already clean: {cleanup_path}")

def create_gitlfs_config():
    """Create Git LFS configuration for published archives"""
    
    print("\nüì¶ SETTING UP GIT LFS FOR PUBLISHED ARCHIVES")
    print("=" * 60)
    
    gitattributes_content = """# Git LFS Configuration for KDP Business
# Large manuscripts and PDFs should be stored in LFS

# Published book files
published_archive/**/*.pdf filter=lfs diff=lfs merge=lfs -text
published_archive/**/*.txt filter=lfs diff=lfs merge=lfs -text
published_archive/**/*.docx filter=lfs diff=lfs merge=lfs -text

# Large cover images
published_archive/**/*.png filter=lfs diff=lfs merge=lfs -text
published_archive/**/*.jpg filter=lfs diff=lfs merge=lfs -text

# Marketing materials
published_archive/**/*.mp4 filter=lfs diff=lfs merge=lfs -text
published_archive/**/*.zip filter=lfs diff=lfs merge=lfs -text

# Business data
business_intelligence/**/*.csv filter=lfs diff=lfs merge=lfs -text
business_intelligence/**/*.xlsx filter=lfs diff=lfs merge=lfs -text
"""
    
    gitattributes_path = Path(".gitattributes")
    
    # Read existing .gitattributes if it exists
    existing_content = ""
    if gitattributes_path.exists():
        with open(gitattributes_path, "r") as f:
            existing_content = f.read()
    
    # Only add our content if not already present
    if "KDP Business" not in existing_content:
        with open(gitattributes_path, "a") as f:
            f.write("\n" + gitattributes_content)
        print("‚úÖ Updated .gitattributes for Git LFS")
    else:
        print("‚è≠Ô∏è Git LFS already configured")

def update_plan_md():
    """Update plan.md with new organization structure"""
    
    print("\nüìã UPDATING PLAN.MD")
    print("=" * 60)
    
    plan_update = """

# üìÅ STRATEGIC BUSINESS ORGANIZATION (Updated 2025)

## Directory Structure
```
/active_production/          # Current series development
  /Large_Print_Crossword_Masters/
    /volume_1/              # AI-generated comprehensive content
    /volume_2/              # Next in pipeline
    /series_metadata.json   # Series tracking
    
/staging/                   # Ready for KDP publishing
  
/published_archive/         # Git LFS archived (post-publishing)
  /2025_Q1/
    /Large_Print_Crossword_Masters_v1_PUBLISHED/
    
/templates/                 # Reusable assets
  /covers/                  # Cover templates and designs
  /metadata/               # Metadata templates
  /marketing/              # Marketing copy templates
  /kdp_guides/            # Publishing guides
  
/business_intelligence/     # Analytics and tracking
  /sales_reports/          # Amazon sales data
  /profit_analysis/        # ROI and cost tracking
  /market_research/        # Niche research data
```

## Workflow Process
1. **Development**: Work in `/active_production/`
2. **Publishing**: Move to `/staging/` when ready for KDP
3. **Archive**: Move to `/published_archive/` after publishing (Git LFS)
4. **Analytics**: Track performance in `/business_intelligence/`

## Git LFS Integration
- All published books automatically stored in Git LFS
- Large manuscripts (>100KB) tracked in LFS
- Business data and analytics in LFS
- Keeps repository lightweight for development

## Organization Benefits
‚úÖ Clear separation of active vs archived content
‚úÖ Series-focused structure for scale
‚úÖ Git LFS for efficient version control
‚úÖ Business intelligence integration
‚úÖ Scalable to 100+ series

"""
    
    plan_path = Path("plan.md")
    if plan_path.exists():
        with open(plan_path, "a") as f:
            f.write(plan_update)
        print("‚úÖ Updated plan.md with new structure")
    else:
        print("‚ö†Ô∏è plan.md not found - creating organization note")
        with open("ORGANIZATION_STRUCTURE.md", "w") as f:
            f.write(plan_update)

def main():
    """Execute the strategic reorganization"""
    
    print("üöÄ STRATEGIC KDP BUSINESS REORGANIZATION")
    print("üìÖ Implementing 2025 Best Practices")
    print("üéØ Goal: Scalable, organized, efficient publishing business")
    print("=" * 80)
    
    # Step 1: Create strategic structure
    structure = create_strategic_structure()
    
    # Step 2: Identify best content versions
    best_versions = identify_best_content()
    
    # Step 3: Migrate to active production
    if best_versions:
        migrate_to_active_production(best_versions)
    
    # Step 4: Clean up old directories
    cleanup_old_directories()
    
    # Step 5: Set up Git LFS
    create_gitlfs_config()
    
    # Step 6: Update plan.md
    update_plan_md()
    
    print("\nüéâ STRATEGIC REORGANIZATION COMPLETE!")
    print("=" * 80)
    print("‚úÖ Clean, organized structure ready for 2025 scaling")
    print("‚úÖ Active production separated from archives")
    print("‚úÖ Git LFS configured for efficient storage")
    print("‚úÖ Business intelligence structure created")
    print("‚úÖ Documentation updated")
    
    print("\nüìà NEXT STEPS:")
    print("1. Review active_production/ for current work")
    print("2. Move completed books to staging/ when ready")
    print("3. Archive published books to published_archive/")
    print("4. Track performance in business_intelligence/")
    
    print("\nüèÜ READY FOR SCALABLE KDP BUSINESS GROWTH!")

if __name__ == "__main__":
    main()