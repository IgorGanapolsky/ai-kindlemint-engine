#!/usr/bin/env python3
"""
Badge Validation Orchestration Agent
Validates that all README badges are working and show real metrics, not fake
"""

import re
import sys
from pathlib import Path
from typing import Any, Dict, List, Tuple

try:
    import requests

    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False


class BadgeValidator:
    """Orchestration agent to validate badges in README files"""

    def __init__(self):
        self.repo_owner = "IgorGanapolsky"
        self.repo_name = "ai-kindlemint-engine"
        self.forbidden_terms = [
            "unknown",
            "placeholder",
            "generated by tests",
            "sonarcloud ready",
            "enabled",
            "monitoring",
            "95%",
            "100%",
            "excellent",
            "awesome",
        ]
        # Real badge patterns that should NOT be flagged
        self.allowed_patterns = [
            r"github\.com/.*/workflows/.*\.svg",  # GitHub Actions
            r"img\.shields\.io/github/",  # GitHub stats
            r"sonarcloud\.io/api/project_badges",  # Real SonarCloud
            r"codecov\.io/.*badge\.svg",  # Real Codecov
            r"codecov\.io/gh/.*/branch/.*/graph/badge\.svg",  # Codecov graph badges
            r"snyk\.io/test/github",  # Real Snyk
        ]

    def extract_badges_from_readme(self, readme_path: Path) -> List[Dict]:
        """Extract all badges from README.md"""
        if not readme_path.exists():
            return []

        content = readme_path.read_text()
        badge_pattern = r"\[\!\[([^\]]*)\]\(([^)]+)\)\]\(([^)]+)\)"
        badges = []

        for match in re.finditer(badge_pattern, content):
            badges.append(
                {
                    "text": match.group(1),
                    "image_url": match.group(2),
                    "link_url": match.group(3),
                }
            )

        return badges

    def validate_badge_url(self, url: str) -> Tuple[bool, str]:
        """Check if badge URL returns valid response"""
        if not HAS_REQUESTS:
            return True, "SKIP (requests not available)"
        try:
            response = requests.get(url, timeout=10)
            if response.status_code == 200:
                return True, "OK"
            else:
                return False, f"HTTP {response.status_code}"
        except Exception as e:
            return False, str(e)

    def check_for_fake_badges(self, badges: List[Dict]) -> List[str]:
        """Detect fake/placeholder badges"""
        issues = []

        for badge in badges:
            text = badge["text"].lower()
            image_url = badge["image_url"]

            # Skip if it matches allowed patterns (real badges)
            is_allowed = False
            for pattern in self.allowed_patterns:
                if re.search(pattern, image_url):
                    is_allowed = True
                    break

            if is_allowed:
                continue

            # Check for forbidden placeholder terms
            for term in self.forbidden_terms:
                if term in text or term in image_url.lower():
                    issues.append(
                        f"âŒ FAKE BADGE: '{badge['text']}' contains placeholder term '{term}'"  # noqa: E501
                    )

            # Check for static shields.io badges (likely fake) - but NOT GitHub stats
            if "shields.io/badge" in image_url and "github" not in image_url:
                if any(
                    term in image_url.lower()
                    for term in ["100%", "95%", "ready", "enabled"]
                ):
                    issues.append(
                        f"âŒ STATIC BADGE: '{badge['text']}' appears to be a static placeholder"  # noqa: E501
                    )

            # Check for missing real service URLs
            if "codecov" in text.lower() and "codecov.io" not in image_url:
                issues.append(
                    "âŒ MISSING SERVICE: Codecov badge doesn't link to codecov.io"
                )

            if "sonar" in text.lower() and "sonarcloud.io" not in image_url:
                issues.append(
                    "âŒ MISSING SERVICE: SonarCloud badge doesn't link to sonarcloud.io"
                )

        return issues

    def validate_all_badges(self, readme_path: Path | None = None) -> Dict:
        """Main validation function"""
        if readme_path is None:
            readme_path = Path("README.md")

        print(f"ğŸ” Badge Validation Agent - Checking {readme_path}")

        badges = self.extract_badges_from_readme(readme_path)
        if not badges:
            return {"status": "error", "message": "No badges found in README"}

        print(f"ğŸ“Š Found {len(badges)} badges to validate")

        results: Dict[str, Any] = {
            "status": "success",
            "total_badges": len(badges),
            "valid_badges": 0,
            "invalid_badges": 0,
            "fake_badges": 0,
            "issues": [],
            "recommendations": [],
        }

        # Check for fake badges
        fake_issues = self.check_for_fake_badges(badges)
        results["issues"].extend(fake_issues)
        results["fake_badges"] = len(fake_issues)

        # Validate URLs
        for badge in badges:
            print(f"ğŸŒ Checking: {badge['text']}")

            # Check image URL
            valid, msg = self.validate_badge_url(badge["image_url"])
            if valid:
                results["valid_badges"] += 1
                print(f"  âœ… Image URL: {msg}")
            else:
                results["invalid_badges"] += 1
                results["issues"].append(
                    f"âŒ BAD URL: '{badge['text']}' image URL failed: {msg}"
                )
                print(f"  âŒ Image URL: {msg}")

            # Check link URL (if different and not a relative path)
            if badge["link_url"] != badge["image_url"]:
                # Skip validation for relative paths (like LICENSE, README.md, etc.)
                if not badge["link_url"].startswith("http"):
                    continue
                valid, msg = self.validate_badge_url(badge["link_url"])
                if not valid:
                    results["issues"].append(
                        f"âŒ BAD LINK: '{badge['text']}' link URL failed: {msg}"
                    )

        # Generate recommendations
        if results["fake_badges"] > 0:
            results["recommendations"].append(
                "ğŸ¯ Replace fake/static badges with real service badges"
            )

        if results["invalid_badges"] > 0:
            results["recommendations"].append("ğŸ”§ Fix broken badge URLs")

        # Final status
        if results["issues"]:
            results["status"] = "failed"

        return results

    def print_report(self, results: Dict):
        """Print validation report"""
        print("\n" + "=" * 60)
        print("ğŸ›¡ï¸  BADGE VALIDATION REPORT")
        print("=" * 60)

        status_emoji = "âœ…" if results["status"] == "success" else "âŒ"
        print(f"{status_emoji} Status: {results['status'].upper()}")
        print(f"ğŸ“Š Total badges: {results['total_badges']}")
        print(f"âœ… Valid: {results['valid_badges']}")
        print(f"âŒ Invalid: {results['invalid_badges']}")
        print(f"ğŸš« Fake: {results['fake_badges']}")

        if results["issues"]:
            print(f"\nğŸš¨ ISSUES FOUND ({len(results['issues'])}):")
            for issue in results["issues"]:
                print(f"  {issue}")

        if results["recommendations"]:
            print("\nğŸ’¡ RECOMMENDATIONS:")
            for rec in results["recommendations"]:
                print(f"  {rec}")

        print("=" * 60)


def main():
    """Run badge validation"""
    validator = BadgeValidator()
    results = validator.validate_all_badges()
    validator.print_report(results)

    # Exit with error code if validation failed
    if results["status"] == "failed":
        sys.exit(1)


if __name__ == "__main__":
    main()
